minimum-remove-to-make-valid-parentheses (push opening brackets, mark non matching closing as '*', in end do the same for rest of braces in the stack)
verifying-an-alien-dictionary (cnt for order, in comparision, first non matching's order comparision, else after end see for length of first and second)
k-closest-points-to-origin (quick select, max heap push k points size, min heap push all points, resize answer to K before returning)
remove-invalid-parentheses (calculate left and right needed, then do dfs with left, right and pair, use Unordered_Set)
valid-palindrome-ii (pointer from last and first, whenever mismatch, 4 pointers and check in end p >= q or a >= b)
subarray-sum-equals-k (unordered_map for storing sum, sum == k and Mp[sum - k] existence)
integer-to-english-words (x >= 20, " " + tens[x/10] + dfs(x %10), and for last "")
alien-dictionary (one major thing is check for l >= minLen and if curr.size() > next.size() implies cannot be done. Topological sort last check for Indegree.size() for no cycles)
product-of-array-except-self (l = 1, r = 1, res of N with 1, multiply l and r then update l and r)
add-binary (i >= 0 or j >= 0 or carry, here mod with 2)
add-strings (i >= 0 or j >= 0 or carry, here mod with 10)
binary-tree-right-side-view (result.size() < depth, add, iterate first on right then left, depth = 1 at start)
serialize-and-deserialize-binary-tree (istringstream for deserialize and ostringstream for serialize, out.str() for string)
merge-k-sorted-lists (Priority Queue, struct compare with opposite to what you want. Dummy node keep doing next)
binary-tree-maximum-path-sum (private: ans = INT_MIN, ans = max(ans, l + r + root->val), return max(l,r) + root->val, trick is l = max(0, left's) and r = max(0, right's))
find-all-anagrams-in-a-string (vector comparison after small's length, check length before jumping. Also at the end after loop do a check)
interval-list-intersections (sort if not provided in question, start of 1 > end of 2| end of 1 < start of 2 and last is intersect, increase whoever's end is smaller)
add-and-search-word-data-structure-design (Trie implement, either by nullptr or unordered_map<char,TrieNode*> , search is dfs basically where if its a character go to that trie node, else go through all children and if one returns true, return true)
continuous-subarray-sum (TRICKY!, Mp[0] = -1, implies no 0 sum is found. if(Mp.count(mod)) then check if(i - Mp[mod] > 1) and update the index if mod is not found in map)
sparse-matrix-multiplication (N M P, i from 0 to N, j from 0 to M, only if A[i][j] != 0, iterate k from 0 to P and do res[i][k] += A[i][j] + B[j][k])
valid-palindrome (use isalnum() and check from both sides with tolower for both)
binary-search-tree-iterator (stack required, do controlledInorder by pushing only left child of root, while top, call controlled inorder for node->right)
intersection-of-two-arrays (unordered_set on 1st)
longest-substring-with-at-most-k-distinct-characters (begin and end concept, while Mp.size() > k, decrement count of begin, check if Mp[s[begin-1]] == 0, Mp.erase(s[begin-1]))
valid-number (first trim spaces on both ends, isESeen, isDotSeen, numberBeforeE, numberAfterE, first check for isdigit, then +/-, then '.', then 'e' and if none return false, lastly if eSeen ? both beforeE and afterE : beforeE)
read-n-characters-given-read4-ii-call-multiple-times (int len, buffCnt = 0, read4 and do whenever buffCnt >= len, while(i < n) and copy to buf[i++] = buffer[buffCnt++])
range-sum-of-bst (if root->val >= L and <= R)return root->val + left + right else only return left + right
accounts-merge (treat accounts as nodes and perform Union Find, unordered_map<string, int> Parent and do merge based on values here, while adding into one, always do int x = Find(s), then add to unordered_map<int, set<string>> for sorted)
diameter-of-binary-tree (private : ans = INT_MIN, ans = max(1 + l + r), return 1 + max(l, r))
expression-add-operators (target, cv, pv, base condition idx > size, idx == size has comparision and first time initialize for idx == 0 and check for len > 1 and at [0] != '0' to avoid leading zeroes)
word-break (dp[N+1] = {push the length of string from this index that is present in the dict}, set of word sizes, start from index N-1 to 0, main condition is (i +size) <= N and dp[i+size].size(), implies that is also valid, but here actually form the substr and check if it exists in the dict)
kth-largest-element-in-an-array ( K = N-K, find through quick select)
missing-element-in-sorted-array (binary search on l=1 and r=INT_MAX, for each Guess(mid) find gap = (Guess - A[0] - idx) where idx = upper_bound())
next-permutation (k = N-1, decrement till A[k] < A[k+1], else if k < 0 already reverse sorted, find l > k greater than k, swap both, reverse(k+1, to end))
exclusive-time-of-functions (struct Log for fancy parsing, stack<Log> res[N], for an event do res[id] += (end - top.time + 1), if there exists another event in stack, reduce the same time from it)
merge-intervals (sort the intervals based on start time, start and end same as first, then check for edges, push after the loop too!)
minimum-window-substring (begin and end concept, kind of two pointers window, increase end and decrement its count, increase begin and increment its count, ans update is done in inner while loop, cnt[s[end++]]-- > 0 implies this was a valid character, cnt[s[begin++]] >= 0 implies valid again)
vertical-order-traversal-of-a-binary-tree (map<int, map<int, set<int>>> for sorted, 0,0 => x-1,y+1 and x+1, y+1)
merge-sorted-array (start from end and merge the larger element till n >= 0)
lowest-common-ancestor-of-a-binary-tree (root==null or == q or == p else find in left and right, return !left ? right : !right ? left : root)
word-break-ii (same as before , dp[i][j] means at index i all valid lengths possible, important to check in dict before adding size, then dfs across dp)
diagonal-traverse (i=0, j=0, d=-1, check for i >= N , j >= M, i < 0 and j < 0, each are if and in each d=-d. i += d and j += -d)
is-graph-bipartite (dfs with expected color. Colors array can act as visited itself in the if condition, if !dfs() return false from there)
closest-binary-search-tree-value (inorder and at each point find the one which gives minimum (double difference = LONG_MAX, double!)
maximum-sum-of-3-non-overlapping-subarrays (dp[M][N] is the value and idx[M][N] is the index, for all its res[i] = idx[i+1][res[i+1]], val = dp[i-1][j-K] + prefix[j] - prefix[j-K])
search-in-rotated-sorted-array (l <= r in binary search, nums[mid] == nums[l] and nums[mid] == nums[r] then, l++, r--; else compare nums[mid] >= nums[l] and inside that check for target's location, same for else.)
random-pick-with-weight (prefix sum for range, generate random() % totalSum and find upper_bound, return idx-1)
task-scheduler (TRICKY! heap to simulate the tasks, by doing a while till PQ is not empty, inside which maintain a vector, another while(i <= n) operations, each you pop and add val-1 if > 0 to tmp, ans++ and then see if both tmp and PQ are empty then break)
maximum-swap (start from right, 4 things, l_max , l_max_idx, left and right, Start from back of array, everytime you update l_max, continue, else if a number is smaller than l_max, update left and right.)
find-k-closest-elements (TRICKY, lower bound to the number's idx, left = idx - K, right = idx+K+1, while(right - left + 1) > K) decrease the size of interval
random-pick-index (Reservoir sampling, res = -1, whenever A[i] == target, then do if(++count == 1), res = i, else if(rand()% count == 0)res = i, this words because count is like total occurence, rand() % count implies 1 / total_occurences)
walls-and-gates (multisource BFS, here the value of grid serves like visited, update them to a level variable for final answer)
first-bad-version (binary search, r = mid, l = mid +1, l < r)
lowest-common-ancestor-of-deepest-leaves (go left and right, return pair<int,TreeNode*> where first is max depth till that node, leaf returns its own depth and itself, at any node compare whichever greater return else return the node itself)
divide-two-integers (divisor == -1 and INT_MIN and INT_MAX cases, dividend == 0 and divisor  == 1, then exp(log(fabs(dividend))- log(fabs(divisor))) and multiply by sign)
group-shifted-strings (hash/ order by difference between consecutive characters, diff = a[i] - a[i-1] < 0 ? diff + 26 : diff, res += string(1, diff + 'a'))
powx-n (handle cases of n < 0, and make things in long for INT_MIN, INT_MAX cases. then use exponential doubling, ans = 1, a = x, till N, a *= a and N >>= 1)
simplify-path (use vector<string> as a stack, getline(ss, tmp, '/'), do checks inside and final answer computation)
reorganize-string (use max heap of count of characters, pop one by one and check if its not equal to last added character, else pop another one from heap)
maximum-difference-between-node-and-ancestor (TRICKY! while returning from each node, always compare with root->val. Same like deepest leaves, go left and right, while coming back, each node return pair<int,int> min and max from both subtrees.)
multiply-strings (intialize answer with size N + M and '0',  start from end of each, sum = ans[i+j+1] + A[i] + B[j], ans[i] += carry, in end, find_first_not_of('0') and return substr(pos))
monotonic-array (bool incr for <= and decr >=, each element check for violation and in the end return incr or decr)
trapping-rain-water (lmax is max of min of height[l] and height[r], ans += lmax - height[idx++])
find-first-and-last-position-of-element-in-sorted-array (implement lower and upper bound, if lower and upper equal then {-1,-1} else {lower, upper-1})
binary-tree-vertical-order-traversal (map<int, map<int, vector<int>>>)
battleships-in-a-board (count in first row, left should not be same, then in each row first element is counted, then for each check for left and up)
similar-string-groups (Union Find on groups based on similarity, diff should be either 0 or 2, in union decrease the number of groups)
range-sum-query-2d-immutable (compute prefix sum for each row, then finding is like going through each row and prefix difference with cols as index, if prefixSum starts with 0, then prefix[maxCol+1] - prefix[minCol])
strobogrammatic-number (Have a vector<char> mapping for each char, two pointers from start and end, V[start] == s[end], else return false)
convert-binary-search-tree-to-sorted-doubly-linked-list (During inorder, first and last both null, if(last) the last->next = root, root->prev = last, last = root everytime, first only else of lastCheck)
nested-list-weight-sum (dfs sum = 0 at each level, traverse through list, integer then add else recurse sum)
insert-delete-getrandom-o1 (vector for numbers, map for <number, index in vector>, insert at end and store index, while removing, swap with last and erase from map and update index of last number with present's index)
restore-ip-addresses (dfs, each index consider to put a dot, allowable dots are 3 and number >= 0 and < 256, for each position check all 1 to 3 lengths substr, with idx + len <= s.size(), while recurse, if curr was empty then dots remain intact else dots-1)
strobogrammatic-number-ii (dfs return base case strings of length 0 and 1, for others, if n != N, add 0 on both sides, rest padding remains same for all length)
basic-calculator-ii (parseExpr, parseNum, with reference of index, in parseExpr check for op != ')', update op after every parseNum, accumulate the vector of longs)
lru-cache (list<pair<int,int>> for key and value, unordered_map<int, list<pair<int,int>> :: iterator> pointing to the ptr of list, when add)
burst-balloons (have a dp of size N+2, and copy original array, now recursive dp with base case left+1 == right return 0, else traverse from left+1 to < right and find dfs maximum)
minimum-knight-moves (Base case of (1,1) return 2, for others, have a helper where to move based on present coordinate, then do simple BFS by keeping visited as string of coordinates)
friends-of-appropriate-ages (Two loop on ages vector having count of people of that age, check conditions, add cntA*cntB to answer but if ageA == ageB in that case ans -= cntA, because n(n-1) => n^2 - n)
meeting-rooms-ii (One approach is to sort the intervals based on start time, use a Min heap based on end time, traverse across the intervals and compare Heap's top's end is <= start of this interval, then pop, else insert this interval into heap, return heap size.||Another approach is keep a map<int,int>, increment on start time, decrement on end time and maximum subarray sum)
sliding-window-median (A,B multiset, insert into A, then insert into B the lastElement of A, erase from A and then balance, removal is kind of same, if it has to be removed from B, then first insert last element from A and then delete, else simply delete from A and call balance)
goat-latin (getline(ss, tmp, ' ') is the key)
clone-graph (unordered_map<Node*, Node*> for original to new nodes. Create the replica of root, do a BFS, every node you dequeue, see if the mapping exists, else create one. While traversing the neighbors keep a unordered_map<Node *, unordered_set<Node*>> for graph, finally construct the graph)
design-tic-tac-toe (use vector<int> rows, cols and int diag, antidiag. Initially everything is 0, whenever a player moves, increment that row and col by 1 or -1 based on which player it is. Diagonal will be changed if row == col and antidiag when row == N - col - 1, any point absolute value == N, then winner is found)
smallest-subtree-with-all-the-deepest-nodes (Same as finding LCA of deepest nodes. Return a pair<int, TreeNode*> and based on comparison of first return appropriate, base condition is {depth, root} for leaves)
best-time-to-buy-and-sell-stock (At most once, this can be done by adding subsequent differences and finding max out of it, like Kadane, variant of the question is given differences find maximum profit, which is same as kadane's)
minimum-add-to-make-parentheses-valid (left and right evaluation, can be done by counters, final answer is left+right)
insert-into-a-sorted-circular-linked-list (prev = head, next = head->next, while(next != head) there are 4 conditions, x == pre| (x > pre and x <= next) | (next < pre and x < next) | (next < pre and x > pre))
check-completeness-of-a-binary-tree (BFS until you find null in queue, break and then check if no non-null child exists in the queue)
add-bold-tag-in-string (use a visited array to mark all the strings that match, use KMP here, after done marking, result string will be based on if boldTag has been added)
tree-diameter (tree is in form of graph, double BFS for longest path, from bfs return the node with longest distance)
all-nodes-distance-k-in-binary-tree (construct a parent map, now do a BFS from this src node, add left, right and parent node by maintaining a visited and level)
regular-expression-matching (dfs dp, base case of j reaching p's size then i == s.size() then a bool match of present character or p is dot, here we need to ensure i < s.size then make dfs based on j+1 == '*' either call j+2 or (match and dfs(i+1), else do (match and dfs(i+1, j+1))))
top-k-frequent-elements (store the counts first, then use min heap, maintain size K)
validate-binary-search-tree (one way to maintain, lowLimit and highLimit in function, else return pair from node, every node check if the node value is within range, better to check for <= lowLimit and >= highLimit and returning false in both)
number-of-islands (use grid as visited and do flood fill)
toeplitz-matrix (start from i=1 to N and j=1 to M, always check for [i][j] == [i-1][j-1])
minimum-number-of-arrows-to-burst-balloons (sort the array by end time, have start as end and then based on intersections increase count)
reorder-list (L0->Ln->L1 and so on, for this find the mid Node using two ptr approach, make slow->next as null and return slow->next by storing it before, reverse the second part and then merge both lists with the given logic by third variable)
number-of-connected-components-in-an-undirected-graph (straight forward Union Find)
find-the-celebrity (assume celeb is zero, start traversing from 1 to N and check knows(celeb, i) if knows then celeb = current i, after that run another loop from 0 to n for the same, if our celeb knows this person or he doesnt know our celeb then return -1)
basic-calculator (parseExpr, parseNum, with reference of index, in parseExpr check for op != ')', update op after every parseNum, accumulate the vector of longs)
island-perimeter (for every island, reduce common and add to answer by checking neighbors)
find-peak-element (Can be done in Logarithm complexity, find mid and check if nums[mid] > nums[mid+1] then high = mid, else low = mid+1, finds first peak)
copy-list-with-random-pointer (three phases, in one insert new nodes between each node using temp and dummy, then copy random pointers by checking temp and temp->next, temp->next->random = temp->random ? temp->random->next : nullptr and then remove original links: same temp and temp->next loop, dummy is temp->next, temp->next is dummy->next, dummy->next depends on dummy->next's existence, temp = temp->next)
flatten-nested-list-iterator (Stack of nestedInteger, from reverse copy everything in the stack as it is until the top is an integer in hasNext())
nth-digit (start with long base = 9, digits = 1, while n > base * digits n -= base * digits, base *= 10, digits++. Finally the offset would be (n-1)/ digits and start would be power(10, digits-1) and index would be (n-1)%digits)
single-element-in-a-sorted-array (binary search, if mid is even then compare it with next, increase the l by mid+2, else r = mid, if odd compare it with previous and l = mid+1, else r = mid)
number-of-ways-to-stay-in-the-same-place-after-some-steps (simple dfs(i) + dfs(i-1) + dfs(i+1), base case of idx < 0 and idx > N is important and if stepsLeft == 0 check if its at start)
reconstruct-itinerary (blind dfs with path recreation, graph is map<string, multiset<string>>, do a dfs on a src until it has children in its graph, pull the first neighbor, erase it from its graph and recurse, add into the path in end, finally reverse the path)
string-to-integer-atoi (first remove spaces from front, have a sign check, long ans = 0, any point if answer exceeds the limits return based on sign, if any other character return, finally return sign * ans)
minesweeper (dfs, if mine then mark and return, else calculate number of mines in surrounding, if there exists then mark the number, else then recurse in all directions again for further squares)
stamping-the-sequence (greedy approach, target is to make the string "****....**", so match greedily and mark "*" based on stamp matching and atleast one char, reverse the order before returning)
word-ladder (Double ended BFS, beginSet and endSet by swapping and ladder + 1 everytime)
combination-sum (dfs with check for sum <= target then add and popback, backtracking)
longest-substring-without-repeating-characters (begin end concept, maximum after inner while)
longest-substring-with-at-most-two-distinct-characters (begin end concept, unordered_map for size, Mp[s[end++]]++, while(mp.size() > 2), increase the begin)
max-consecutive-ones-iii (begin end concept, longest string with at most K zeroes.)
palindromic-substrings (expand around center and keep counting)
binary-tree-paths (dfs with path storing, add only when leaf is found)
3sum (sort the array, then for every i from 1 to n-3, j = i+1, k = N-1, check accordingly, skip when i > 0 and A[i] == A[i-1], also once u add nums of i,j,k, increase j and decrease k, then iterate until they are same)
target-sum (dfs simple, either add number of subtract number)
intersection-of-three-sorted-arrays (can be solved without extra space, i, j and k all zero. if all are equal then add to answer and increase all, else increase who are smaller)
implement-magic-dictionary (add words to set then search for all combinations)
two-sum (unordered_map and on the fly you can check)
find-largest-value-in-each-tree-row (simple BFS)
friend-circles (simple BFS, the adjacency list is given)
shortest-distance-from-all-buildings (have a target varible each time, finally calculate only for the ones whose value is equal to target, additional space for dp and modify original array)
koko-eating-bananas (discrete binary search, from 1 to INT_MAX, for every mid if its possible)
convert-sorted-list-to-binary-search-tree (compute the length of the linked list, then you have l and r, between those construct the tree in inorder fashion, find mid, call inorder(head, l, mid-1), after this make the root node, head=head->next, call for right mid+1, end and then return.| Another approach is to use fast and slow pointer to find mid everytime then recursively call for left and right by start to slow and slow->next to end)
number-of-islands-ii (Union Find with unordered_set of lands, every point answer is groups + lands.size() - mn, trick is id = i*m + j)
valid-parenthesis-string (dfs based on open braces count, one tricky thing if its closing bracket, dp would be open > 0 and dfs(i+1, open-1))
generate-parentheses (open, closed count based dfs dont add return dfs. Simply call dfs)
backspace-string-compare (vector to simulate both return A == B vector)
intersection-of-two-arrays-ii (unordered_map for storing count as well)
minimum-area-rectangle (two points as diagonal, simulate other two points and calculate area, in end do check for INT_MAX comparison)
longest-arithmetic-sequence (dp[i][diff], if N <= 2 answer is 2, vector<map<int,int>> dp(N), each index have all differences. Do two loops, find diff. if dp[i].count(diff) then simply dp[j][diff] = dp[i][diff]+1, else dp[j][diff] = 2 elements)
max-area-of-island (dfs flood fill)
course-schedule (build the graph and then check if Topological sort can be done using Kahn's algorithm, first push all with 0 indegree, pop and then decrement count of Indegree of all neighbors, push those with 0 new indegree)
largest-bst-subtree (TRICKY, from each node return a INFO (isBST, size, max value in it, min value in it, ans till here), base cases are null root, leaf, then recurse for left and right. At this compute mx_val and mn_val and size and max answer to be passed above. Check for BST by left.isBST and right.isBST and root->val > left.mx and root->val < right.mn))
insert-interval (start and end, traverse each interval and merge, by checking start, end and min, max of each)
kth-smallest-element-in-a-sorted-matrix (find minimum and maximum amongst the entire array, those become limits of binary search. Now do discrete binary search, where function returns number of elements greater than mid)
top-k-frequent-word (count and then Min heap for size > K , TRICKY part is in final result start inserting from backwards because for same frequency we need it sorted)

